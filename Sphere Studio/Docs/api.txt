minisphere 1.4 API Documentation
================================

minisphere uses JavaScript for game logic. This is similar to the Sphere
engine, which minisphere is designed to be compatible with.  In fact,
the vast majority of the API is identical to Sphere's, with a handful of
backwards-compatible enhancements.

This file documents the functions exposed by minisphere for use in game
scripts. This list is not yet exhaustive; see the included Sphere 1.5 API
reference for the full list of legacy functions (a few may not be supported,
however).


Engine Identification
---------------------

The functions below can be used to determine, at a broad level, the
engine's level of support for various features.

GetVersion()

  Returns the Sphere API version level as a floating point number. When called
  under minisphere 1.4, this function returns 2.0, indicating Sphere API version
  2.

GetVersionString()

    Returns the engine's version identification string. For minisphere 1.4, this
    string is:
      
      v2.0 (compatible; minisphere 1.4.0)

GetExtensions()

  Returns an array of strings representing the engine's built-in
  capabilities. minisphere currently supports the following extensions (most of
  these should be self-explanatory):
  
    * minisphere
    * sphere-legacy-api
    * sphere-obj-constructors
    * sphere-obj-props
    * sphere-map-engine
    * sphere-commonjs
    * sphere-galileo
    * sphere-spherefs
    * minisphere-async-api
    * minisphere-galileo-shaders
    * minisphere-new-sockets
    * minisphere-rng-object
    * frameskip-api
    * set-script-function


SphereFS File System
--------------------

minisphere follows the SphereFS standard for file paths. When providing a
filename to a function or method, it will be treated as relative to a specific
directory by default, generally a subdirectory below the current game's
game.sgm. To get around this and load files from a different location, you can
use one of the following SphereFS prefixes:

  ~usr/: The current user's local home directory. This may be used to store
         save files and other such data where the user can easily access it.
         Guaranteed to be writable on all systems.
  ~sgm/: The directory containing game.sgm. For backwards compatibility, this
         may also be specified as ~/. You should not assume this is writable.
  ~sys/: minisphere's "system" directory. May be used to access assets included
         with the engine. Not likely to be writable.

By way of example, the following will open the file settings.cfg from the
calling game's "config" subdirectory:
  
  var file = new File("~sgm/config/settings.cfg");


Dependency Management
---------------------

Outside of very simple one-off games, most projects will consist of multiple
script files. You will need to know how to use the functions below if you expect
to get very far!

RequireScript(filename)
EvaluateScript(filename)

  'filename' is relative to ~sgm/scripts unless escaped.
  
  Evaluates the contents of `filename`, as if the code contained within
  were part of the script containing the call. If you've ever worked in
  C or C++, this is a bit like including a header file.
  
  Note: RequireScript only executes a given script once, regardless
  of how many RequireScript() calls specifying it are encountered. This
  is generally preferable to EvaluateScript(), which always executes the
  script.

RequireSystemScript(filename)
EvaluateSystemScript(filename)
  
  'filename' is relative to ~sys/scripts. SphereFS prefixes are not allowed.
  
  Same as above, except the script is loaded from the engine's system directory.
  These are used to import scripts included with the engine.


CommonJS
--------

In addition to the classic dependency management functions described above,
minisphere also supports CommonJS modules.  To load these, the built-in
require() function is provided.

require(module_id);

  Loads a CommonJS module and returns its export table. `module_id` is an
  abstract path (a string) identifying the module to load, with the same
  semantics as in, e.g. Node.js. If the module cannot be found, an error will be
  thrown. minisphere will look for modules in the following locations:
  
    ~sgm/modules
    ~sys/modules
  
  If require() is called inside of a module and the ID provided is prefixed with
  either './' or '../', this specifies a path relative to the calling module.


Basic Debugging
---------------

minisphere doesn't include a stepping debugger, so these may come in
handy!

Abort(message[, stack_offset])

  Forces the engine to close, displaying a specified error message. The
  error is normally said to originate at the location of the Abort()
  call; you may pass an optional negative stack offset to blame it on a
  function earlier in the call chain. For example, the following code
  will report an error at the point PassTheBuck() is called instead of
  at the Abort() call:
  
  function PassTheBuck()
  {
      Abort("PassTheBuck() says: It's not my fault!", -1);
  }
  PassTheBuck();

Alert(message[, stack_offset])

  Similar to Abort(), except the message is displayed in a dialog box
  and the game continues running as normal afterwards. Useful for
  examining variables at runtime when debugging.

Assert(condition, error_message[, stack_offset]);
  
  If `condition` evaluates to true, does nothing. Otherwise an error is thrown
  with the error text set to `error_message`. In the Console engine, the error
  is shown in a dialog box with the option to ignore it.


Logging
-------

Logging is another useful debugging tool. When trying to diagnose a stubborn
bug, it often helps to be able to see a detailed summary of everything that
happened when the issue surfaced. Of course, this requires some vigilance on the
part of the developer to output enough log entries!

new Logger(filename)

  'filename' is relative to ~/logs unless escaped.
  
  Opens a file for logging and constructs an object you can use to access the
  log. An error will be thrown if the file cannot be opened for writing.

Logger:write(text)
  
  Logs a line with the specified `text` at the current indent level.

Logger:beginBlock(name)
  
  Opens a block with the heading `name` and increases the indent level. Blocks
  can be nested and are useful to group related log entries.

Logger:endBlock()
  
  Closes the innermost block and decreases the indent level.


Timing Functions
----------------

These are used to measure elapsed time during gameplay and coordinate timed
events.

GetTime();

  Returns the number of milliseconds elapsed since some arbitrary point in time
  (usually engine start). If you need more precision, use GetSeconds() instead.

GetSeconds();

  Returns the amount of time in seconds, in floating point, since some arbitrary
  point in time. Precision is guaranteed to be < 1Âµs.

Delay(ms);
  
  Suspends game execution for 'ms' milliseconds.


Execution Control and Game Management
-------------------------------------

Most of these are only useful for startup games, which can be distributed with
the engine and allow the user to choose a game to play. For these functions to
work, a `games` directory must be placed in the same directory as the engine,
alongside the `system` directory, with subdirectories for each game.

GetGameInformation()
  
  Returns an object describing the currently running game. The object is of the
  same form as those returned by GetGameList() (see below), with the caveat that
  the directory path returned is absolute instead of relative.

GetGameList()

  Returns an array of objects, one for each Sphere game found in
  [engine root]/games. Each object has the following properties:
    
    .name:        The game's title, taken from game.sgm.
    .directory:   The directory the game was found in, relative to
                  [engine root]/games. For packaged games, this will be the
                  name of the package file instead of a directory name.
    .author:      The game's author, taken from game.sgm.
    .description: A short description of the game, taken from game.sgm.

ExecuteGame(directory)

  Replaces the currently running game with the one found in the
  specified directory. The directory is assumed to be relative to
  [engine root]/games.

RestartGame()

  Restarts the current game. All game state is cleared and the game()
  function is called again, as if the game was just started.

Exit()
  
  Exits the current game and shuts down the engine. If the current game
  was started by via ExecuteGame(), the original game will be restarted
  following the Exit() call.
  
Async(script);
  
  Queues a script or function to be executed on the next FlipScreen() call. This
  is similar to setTimeout(func, 0); in the browser.


Keyboard Routines
-----------------

What would a game be without the ability for the player to control it? This set
of functions allows your game to accept input via the keyboard, the most common
input method for a PC game. First of all, the available keycodes:

  KEY_ESCAPE     
  KEY_F1         
  KEY_F2         
  KEY_F3         
  KEY_F4         
  KEY_F5         
  KEY_F6         
  KEY_F7         
  KEY_F8         
  KEY_F9         
  KEY_F10        
  KEY_F11        
  KEY_F12        
  KEY_TILDE      
  KEY_0          
  KEY_1          
  KEY_2          
  KEY_3          
  KEY_4          
  KEY_5          
  KEY_6          
  KEY_7          
  KEY_8          
  KEY_9          
  KEY_MINUS      
  KEY_EQUALS     
  KEY_BACKSPACE  
  KEY_TAB        
  KEY_A          
  KEY_B          
  KEY_C          
  KEY_D          
  KEY_E          
  KEY_F          
  KEY_G          
  KEY_H          
  KEY_I          
  KEY_J          
  KEY_K          
  KEY_L          
  KEY_M          
  KEY_N          
  KEY_O          
  KEY_P          
  KEY_Q          
  KEY_R          
  KEY_S          
  KEY_T          
  KEY_U          
  KEY_V          
  KEY_W          
  KEY_X          
  KEY_Y          
  KEY_Z          
  KEY_SHIFT      
  KEY_CTRL       
  KEY_ALT        
  KEY_SPACE      
  KEY_OPENBRACE  
  KEY_CLOSEBRACE 
  KEY_SEMICOLON  
  KEY_APOSTROPHE 
  KEY_COMMA      
  KEY_PERIOD     
  KEY_SLASH      
  KEY_BACKSLASH  
  KEY_ENTER      
  KEY_INSERT     
  KEY_DELETE     
  KEY_HOME       
  KEY_END        
  KEY_PAGEUP     
  KEY_PAGEDOWN   
  KEY_UP         
  KEY_RIGHT      
  KEY_DOWN       
  KEY_LEFT       
  KEY_NUM_0
  KEY_NUM_1
  KEY_NUM_2
  KEY_NUM_3
  KEY_NUM_4
  KEY_NUM_5
  KEY_NUM_6
  KEY_NUM_7
  KEY_NUM_8
  KEY_NUM_9
  KEY_CAPSLOCK
  KEY_NUMLOCK
  KEY_SCROLLLOCK

GetPlayerKey(player, button);
SetPlayerKey(player, button, keycode);

  Gets or sets the keycode mapped to a specified playerkey. Playerkeys mirror
  the layout of a Super NES controller. GetPlayerKey() should be used in place
  of hardcoded keys whenever possible, in order to allow the player to customize
  the mappings. 'player' can be one of the following values:
    
    PLAYER_1
    PLAYER_2
    PLAYER_3
    PLAYER_4
  
  'button' can be one of the following:
    
    PLAYER_KEY_UP
    PLAYER_KEY_RIGHT
    PLAYER_KEY_DOWN
    PLAYER_KEY_LEFT
    PLAYER_KEY_MENU
    PLAYER_KEY_A
    PLAYER_KEY_B
    PLAYER_KEY_X
    PLAYER_KEY_Y
  
  Modifications made by SetPlayerKey() are persistent; the new mapping will be
  saved to your game's "save" directory when the engine exits and reloaded when
  the game is started again. Key mappings for other games are not affected.
  
  See key-mapping.txt for more information on these functions and an easy way
  you can allow your players to change the key mappings.

IsKeyPressed(keycode);
IsAnyKeyPressed();

  Returns true if the user is currently pressing either a specified key, or any
  key on the keyboard, respectively.

GetToggleState(keycode);

  Gets the state of the specified toggle key, which should be one of the
  following:
  
    KEY_CAPSLOCK
    KEY_NUMLOCK
    KEY_SCROLLLOCK

  Passing any other keycode will throw an error.

AreKeysLeft();
GetKey();
  
  GetKey() returns the keycode of the next key in the keyboard queue. If the
  queue is empty, it will wait until the user presses a key. AreKeysLeft()
  returns true if keys are pending, and should be used to avoid delays if such
  behavior is undesirable.

ClearKeyQueue();
  
  Removes all keys from the keyboard queue.

BindKey(keycode, on_down_script, on_up_script);
UnbindKey(keycode);

  BindKey() executes a script whenever the player presses or releases a
  specified key. The scripts can be either functions, source code strings, or
  null/undefined (to do nothing).  Note that bound keys are only honored during
  the main loop of a MapEngine() call.
  
  UnbindKey() removes a binding created by BindKey().


Joystick Routines
-----------------

These functions allow your game to accept joystick and gamepad input for a more
console-like experience.

GetNumJoysticks();

  Returns the number of joysticks currently available for use.

GetNumJoystickAxes(joystick);
GetJoystickAxis(joystick, axis);

  Gets the current position of a joystick axis. 'joystick' and 'axis' are zero-
  based indices whose exact meaning depends on the device and system. Return
  value ranges from -1.0 to 1.0, with zero indicating dead center. Call
  GetNumJoystickAxes() to get the number of available axes.
  
  Note: Joystick indices are not set in stone, even on the same system, and can
  change, e.g. after a reboot.

GetNumJoystickButtons(joystick);
IsJoystickButtonPressed(joystick, button);

  Returns true if a specified joystick button is pressed. 'button' is a zero-
  based index whose exact mapping depends on the device in question. Call
  GetNumJoystickButtons() to get the number of available buttons.

BindJoystickButton(joystick, button, on_down_script, on_up_script);
UnbindJoystickButton(joystick, button);

  Like BindKey() and UnbindKey() above, but binds a joystick button instead of
  a keyboard key. As with BindKey(), bound joystick buttons are only honored in
  the main MapEngine() loop.


Mouse Input Routines
--------------------

Rounding out the input routines are the mouse functions. Most games don't need
mouse support, but it's available if you do need it.

GetMouseX();
GetMouseY();
SetMousePosition(x, y);

  Gets or sets the location of the mouse cursor, in pixels, relative to the game
  screen.
  
IsMouseButtonPressed(button);

  Returns true if the player is pressing the specified mouse button. 'button'
  can be one of the following:
  
    MOUSE_LEFT:   Left button
    MOUSE_MIDDLE: Middle or wheel button
    MOUSE_RIGHT:  Right button

GetNumMouseWheelEvents();
GetMouseWheelEvent();

  GetMouseWheelEvent() returns the next mouse wheel event in the wheel queue. If
  the queue is empty, waits until the player moves the wheel. If this behavior
  is undesirable, call GetNumMouseWheelEvents() first to make sure the queue
  isn't empty.


Random Number Generation
------------------------

Many games have need of a good random number generator, particularly RPGs. All
JavaScript engines have a built-in generator in the form of the Math.random()
function, however this is generally considered subpar. minisphere provides the
RNG object, which uses the MT19937 (Mersenne Twister) algorithm to generate
high-quality random values and allows manual seeding.

RNG.seed(seed);

  Seeds the random number generator with `seed`. If the seed is floating point,
  it will be truncated to an integer; using a seed of 812.88, for example, has
  the same effect as 812.

RNG.random();

  Returns a floating point value in the range [0,1). This is the basic method of
  random number generation, and a direct, drop-in replacement for Math.random().

RNG.chance(odds);

  Tests a percentage chance. Returns true if the chance succeeds, false
  otherwise. `odds` is a value between 0 and 1; for example, 0.75 will return
  true 75% of the time.

RNG.normal(mean, sigma);

  Returns a random floating point value normally distributed around `mean` with
  a standard deviation specified by `sigma`. The probability distribution of
  this function is sometimes termed a "bell curve."

RNG.range(min, max);

  Returns a random integer uniformly distributed within the range [min,max].

RNG.sample(array);

  Returns a single randomly-chosen item from `array`.

RNG.vary(mean, variance);

  Returns a random floating point value uniformly distributed around `mean` with
  a maximum deviation specified by `variance`.


Graphics Routines
-----------------

minisphere, like Sphere, uses double-buffered rendering. In this scheme, all
drawing is done to a backbuffer, which is not visible to the user, and then
"flipped" once per frame, so that the player only sees the final rendering
output.

FlipScreen();

  Flips the backbuffer. Note that this also performs event loop processing, so
  if it is not called regularly, the engine will stop responding.

GetFrameRate();
SetFrameRate(fps);

  Gets or sets the current target frame rate. Your game will be automatically
  throttled to match this framerate. If `fps` is zero, the game will be
  unthrottled, which may be useful for benchmarks but otherwise is usually a
  waste of CPU resources.

GetScreenWidth();
GetScreenHeight();

  Gets the current screen resolution width and height.

SetClippingRectangle(x, y, width, height);
GetClippingRectangle();
  
  Gets or sets the clipping rectangle. All rendering done to the backbuffer is
  constrained to this rectangle. Note that GetClippingRectangle() returns the
  current clipping rectangle as an object describing it, with `x`, `y`, `width`
  and `height` properties.

ApplyColorMask(color);
  
  Applies a full-screen color mask. The color passed in is multiplied with the
  pixels of the backbuffer to tint the screen. This may be used for, e.g.
  day/night effects.


Frame Skipping
--------------

minisphere has an aggressive frame skipping algorithm which avoids rendering
to the backbuffer if it determines that a frame will be late. This helps keep
the engine running at full speed even on lower-end computers. The following
functions are provided to manage frame skipping.

IsSkippedFrame();
  
  Returns true if the engine has marked the current frame for skipping. Useful
  to avoid performing extra rendering calculations when nothing is going to be
  rendered anyway.

GetMaxFrameSkips();
SetMaxFrameSkips(max_skips);

  Gets or sets the maximum number of consecutive frames the engine is allowed
  to skip. The default is 5 frames. If your game uses GrabImage or GrabSurface
  pervasively, it may be useful to set this to zero. This will almost certainly
  lead to lag, however.
  
UnskipFrame();

  Instructs the engine to re-enable rendering for the current frame if it has
  been marked for skipping. This also clears the backbuffer. This function can
  be used in lieu of SetMaxFrameSkips(0) during sections which make heavy use of
  GrabImage or GrabSurface without impacting performance for the rest of the
  game.


Galileo Graphics API
--------------------

Wondered what that `sphere-galileo` extension was above? This is it! It's a
more modern approach to graphics rendering based on precomposing scenes from
groups of shapes which can then be transformed and rendered as a unit.

All the old-school primitives provided by Sphere 1.5 are still available in
minisphere. However, there's a newer, much more modern way: the Shape and Group
objects.  With these, you precompose a complex object out of a set of vertices
and textures which are then uploaded to the GPU to save time during the main
render loop.

new Color(red, green, blue[, alpha]);
  
  Constructs a new Color object. Color objects are used to specify the color of
  elements such as vertices and primitives. Color components should be in the
  range [0-255] and out-of-range values will be silently clamped. 'alpha'
  specifies opacity and defaults to 255 if not provided.

Color:clone();
  
  Copies this Color object to a new one. Changes to the new object will not
  affect the original.

Color:red (read/write)
Color:green (read/write)
Color:blue (read/write)
Color:alpha (read/write)

  Gets or sets the individual components of the color. Values outside the range
  of [0-255] are accepted, but the engine will automatically clamp them during
  rendering.

BlendColors(color1, color2);
  
  Averages two colors and returns the new Color object from the result.

BlendColorsWeighted(color1, color2, w1, w2);

  Returns a new Color object which is a weighted average of the two passed in.
  'w1' and 'w2' are the relative weights of the two colors.

new Image(filename);
  
  'filename' is relative to ~/images unless escaped.
  
  Constructs a new Image object from an image file. 'filename' will be relative
  to your game's "images" directory. Images can be used as textures for
  Shape objects or drawn directly using the legacy method Image:blit(). Images
  are read-only. If you need a writable image, you should use a Surface object.

new Image(surface);
  
  Creates an Image object with the contents of a specified surface. This can be
  used to regain rendering performance after composing the surface.

Image:width (read-only)
Image:height (read-only)

  Gets the width or height of the image, in pixels.

new Vertex(x, y[, color[, u, v]]);
  
  Constructs an object describing a vertex of a shape. x and y specify the
  location of the vertex relative to the shape's origin. The color, if
  specified, is multiplied with the texture at that point in the shape to "tint"
  the vertex.  U/V are texture coordinates ranging from 0 to 1 describing the
  part of the texture which will be mapped to that vertex.

new Shape(vertices, image[, primitive_type]);

  Constructs a primitive shape out of the provided array of vertices textured
  with the Image object specified by `image`. `primitive_type` is optional and
  can be one of the following:
    
    SHAPE_AUTO - Primitive type is determined automatically based on the number
                 of vertices. This is the default.
    
    SHAPE_POINT_LIST - A point list. Each vertex represents a single point to be
                       rendered. Useful for particle effects.
  
    SHAPE_LINE_LIST - A line list. Each pair of vertices represents a line
                      segment.
    
    SHAPE_TRIANGLE_LIST - A triangle will be drawn for every 3 vertices.
    
    SHAPE_TRIANGLE_STRIP - A triangle strip. The first 3 vertices represent a
                           complete triangle, and each subsequent vertex is
                           combined with the previous two to form another.
                           Number of triangles drawn is equal to
                           (num_verts - 2).
    
    SHAPE_TRIANGLE_FAN - A series of triangles is drawn, all sharing the first
                         vertex. As with a strip, the number of triangles is
                         equal to (num_verts - 2).

Shape:image (read/write)
  
  The Image to be used when texturing the shape. This can be null, in which case
  the vertex colors alone will determine the rendered shape's appearance.

new Group(shapes, shader);
  
  Constructs a Group out of the provided array of Shape objects. `shader` is the
  shader program to use when rendering the group, obtained by calling either the
  ShaderProgram constructor or GetDefaultShaderProgram(). See below for more
  information on shaders.

Group:draw();
  
  Renders the group to the backbuffer. Any transformations specified for the
  group (see below for properties) are applied as if the entire group were a
  single primitive.

Group:x (read/write)
Group:y (read/write)
  
  Sets the location the Group will be drawn at. When using default shaders,
  these are in raster coordinates where +X is right and +Y is down. Note that
  the translation described by these values is applied *after* rotation. To
  apply translation before rotation, use the `rotX` and `rotY` properties (see
  below).

Group:angle (read/write)
  
  The entire Group is rotated by this angle when rendered.

Group:rotX (read/write)
Group:rotY (read/write)
  
  Specifies the amount by which to translate before rotation is applied. The
  shapes in the group will revolve about the origin at a distance determined by
  these values.

Group:shader (read/write);

  Gets or sets the ShaderProgram used when rendering this Group.

GetDefaultShaderProgram();
  
  Gets the default Galileo shader program. This is a very barebones shader which
  uses screen coordinates for vertices and performs only basic texture mapping
  in the fragment shader.

new ShaderProgram(shader_files);
  
  Constructs a ShaderProgram from a set of shader sources. `shader_files` should
  be an object with the following properties:
    
    vertex:   The filename of the source for the vertex shader.
    fragment: The filename of the source for the fragment shader.

  Note: Shader filenames are relative to ~/shaders unless escaped.


Color Matrices
--------------

A color matrix is used to transform indivual pixel colors similar to the way
matrices are used in graphics to transform points. Color matrices operate on the
individual color components (RGB) of the pixel, as follows:

  [ rn, rr, rg, rb ]   [r]    r' = rn + (rr * r + rg * g + rb * b) / 255
  [ gn, gr, gg, gb ] * [g]    g' = gn + (gr * r + gg * g + gb * b) / 255
  [ bn, br, bg, bb ]   [b]    b' = bn + (br * r + bg * g + bb * b) / 255

new ColorMatrix(rn, rr, rg, rb, gn, gr, gg, gb, bn, br, bg, bb);

  Constructs a new ColorMatrix object which can be used in color transformation
  operations. All arguments are required and specify the contents of the matrix.

ColorMatrix.apply(color);
  
  Applies the matrix to the specified color value and returns the output color.


Surfaces
--------

A surface is a writable image which you can render primitives, images and other
surfaces to to compose an image behind-the-scenes and later render it all at
once. Surfaces are allocated from main memory, which allows fast manipulation
at the expense of direct rendering performance.

new Surface(width, height[, fill_color]);

  Constructs a new surface with the specified width and height, optionally
  filled with 'fill_color'. If a fill color is not provided, the created surface
  will be filled with transparent pixels.

new Surface(filename);
  
  'filename' is relative to ~/images unless escaped.

GrabSurface(x, y, width, height);
  
  Creates a surface with the contents of the specified portion of the
  backbuffer. If this called during a skipped frame, the content of the created
  surface is undefined. See the documentation for the Frameskip API above for
  information on how to mitigate this.

Surface:width (read-only)
Surface:height (read-only)

  Gets the width or height of the surface, in pixels.

Surface:clone();

  Creates a new surface from the contents of this one. Modifications to the new
  surface will not affect the original.

Surface:save(filename);

  'filename' is relative to ~/images unless escaped.
  
  Saves the contents of the surface to an image file. The filename extension
  determines the format of the saved image. Supported formats are PNG, BMP and
  JPG.


Windowstyles
------------

Windowstyles are used add flair to menus and text boxes, especially in RPGs.
You can create as many windowstyle objects as you want, so they provide a
standardized way to allow the player to customize the style of such elements in
a game.

new WindowStyle(filename);

  'filename' is relative to ~/windowstyles unless escaped.
  
  Constructs a WindowStyle object from a windowstyle file. The file must be in
  Sphere RWS format.
  
WindowStyle:colorMask (read/write)

  Gets or sets the windowstyle color mask. This is the color that is combined
  with the windowstyle images to tint the rendered window. If this is not
  modified, the default color is #FFFFFFFF and the windowstyle will be rendered
  as-is.

WindowStyle:drawWindow(x, y, width, height);

  Renders a window to the backbuffer using this windowstyle. Note that the
  dimensions provided include the window border, so you will need to make it a
  bit larger than your content.


Fonts and Text Rendering
------------------------

A common task in a game engine, at some point you will probably want to get text
on the screen.  In minisphere, you use a Font object to do this.

GetSystemFont();
  
  Returns a Font object for the engine's built-in default font. This can be used
  in lieu of the Font constructor for prototyping--or even if you just prefer
  the default font.

new Font(filename);
  
  'filename' is relative to ~/fonts unless escaped.
  
  Constructs a Font object from a font file. The file must be in Sphere RFN
  format.

Font:clone();
  
  Creates a new Font object by copying everything from this one. Modifications
  to the cloned font then won't affect the original.

Font:colorMask (read/write)
  
  Gets or sets the color mask, which is blended with the font bitmaps when text
  is rendered using the font.

Font:height (read-only)

  Gets the line height, in pixels, for text rendered using this font.

Font:getCharacterImage(cp);
  
  Gets an Image object for a specified character glyph. 'cp' is an integer in
  range [0-255] specifying the ASCII character code.

Font:setCharacterImage(cp, image);
  
  Sets the glyph image for a specified character. 'cp' has the same meaning as
  above and 'image' is the replacement Image object. Note that replacing glyph
  images requires the font metrics to be recalculated, which may cause
  performance issues if overused.

Font:getStringWidth(string);

  Gets the width, in pixels, of 'string' if it were rendered using this font.

Font:getStringHeight(string, wrap_width);
  
  Gets the height, in pixels, of the string if it were rendered using using
  Font:drawTextBox(), passing 'wrap_width'.

Font:wordWrapString(text, wrap_width);

  Wraps 'text' as if it were drawn with Font:drawTextBox() with the specified
  wrap width. Returns an array of strings, representing the lines of the wrapped
  string.

Font:drawText(x, y, text);

  Renders 'text' at (x,y) using this font. The text is not wrapped.

Font:drawZoomedText(x, y, scale, text);
  
  Renders 'text' at (x,Y0 using this font, scaled according to 'scale'. For
  example, a scale of 2.0 is double size. As with Font:drawText(), the text is
  not wrapped.

Font:drawTextBox(x, y, width, height, x_offset, text);
  
  Renders 'text' at (x,y) wrapped and constrained to a box of the specified
  width and height. 'x_offset' is added to the X coordinate to offset the text.


Sound Routines
--------------

Playing sounds and music are both handled in minisphere by the Sound object.

new Sound(filename);
  
  'filename' is relative to ~/sounds unless escaped.
  
  Constructs a Sound object from the specified sound or music file. The sound
  will be streamed from the file system. Supported sound formats are Ogg Vorbis
  (.ogg), WAV, MOD, S3M, IT, and FLAC. minisphere does not support mp3 or MIDI.

Sound:playing (read-only)

  true if the sound is currently playing, false otherwise.

Sound:length (read-only)
  
  Gets the length of the sound in microseconds.

Sound:pan (read/write)

  Gets or sets the currently pan (balance). 0.0 is dead center, -1.0 is full
  left and 1.0 is full right.

Sound:pitch (read/write)

  Gets the current relative pitch of the sound. 1.0 is normal. Note that this
  is not a true pitch adjustment: the playback speed will be altered.

Sound:position (read/write)
  
  Gets or sets the playback position within the sound, in microseconds.

Sound:repeat (read/write)

  Gets or sets whether the sound will automatically repeat when it reaches the
  end.

Sound:seekable (read-only)
 
  Gets or sets whether the sound is seekable. Currently all supported formats
  are seekable, so this will always be true.

Sound:volume (read/write)
  
  Gets or sets the current volume of the sound, range [0-255].

Sound:pause();
  
  Pauses the sound. If it is already paused, this has no effect.

Sound:play([is_looping]);
  
  Begins or resumes sound playback. The semantics of this function are a bit
  counterintuitive, but match the behavior of Sphere 1.5. When called with no
  arguments, Sound:play() resumes a paused sound. Otherwise, the sound is
  restarted from the beginning (even if it was already playing). If 'is_looping'
  is true, the sound will automatically repeat when playback ends.

Sound:reset();
  
  Seeks to the beginning of the stream. Playback state is not altered; if the
  sound is playing at the time of this call, it simply starts over from the
  beginning. Essentially, this has the same effect as setting Sound:position to
  zero.

Sound:stop();
  
  Stops the sound. The playback position will be reset to the beginning, even if
  the sound was not playing.


Byte Arrays
-----------

A byte array is a buffer containing raw data. Byte arrays are used for both
networking as well as in binary file I/O. See the sections below for more
information about those.  Byte arrays can be used like any other array, via the
indexing operator [], however values written to the array must be numeric and
are automatically coerced to 8-bit integers (range 0-255).

new ByteArray(num_bytes);
  
  Constructs a byte array which can hold 'num_bytes' of data. A byte array
  cannot be resized after it is created, so you will have to plan ahead to
  choose the right size. Note that byte arrays start out empty, with all bytes
  set to zero.

new ByteArray(string);
  
  Constructs a byte array from the bytes of the provided string. The size of
  the created byte array will be the number of bytes in the string (which may
  be greater than the string length!).

ByteArray:length (read-only)
ByteArray:size (read-only)

  Gets the size of the byte array, in bytes.

ByteArray:concat(byte_array);

  Returns a new byte array which is the result of appending 'byte_array' to the
  end of the one this method is called for.

ByteArray:deflate([level]);
  
  Compresses the data in the byte array using the zlib deflate algorithm and
  returns a new ByteArray containing the compressed data. 'level' specifies the
  relative compression level in the range [0-9]. If not provided, a default
  level is used (usually 6).

ByteArray:inflate([max_size]);
  
  Decompresses a byte array containing deflated data. If the byte array doesn't
  contain valid compressed data such as generated by deflate(), an error will be
  thrown. 'max_size' specifies the maximum size of the uncompressed data.  If it
  is omitted, the inflate buffer will be dynamically sized to fit the data.
  
  Important: It is recommended to provide a maximum buffer size to inflate()
             whenever possible. Not doing so leaves the engine vulnerable to an
             inflation bomb attack.
  
ByteArray:slice(start[, end])
  
  Returns a new byte array which is the result of copying all bytes between
  start and end, exclusive. If 'end' is negative, it is relative to the end of
  the byte array; if it is omitted, the entirety of the array from 'start'
  onwards is taken.

CreateStringFromByteArray(byte_array);
  
  Builds a string from the bytes in 'byte_array'.

CreateByteArrayFromString(string);

  Constructs a ByteArray from the specified string.
  

Networking (Sockets)
--------------------

minisphere includes an advanced sockets API which is more flexible than the one
Sphere provides. The old routines are still available, but should be considered
deprecated. Under minisphere, sockets are divided into two types: Listening
sockets, used for servers, and I/O sockets, for clients.

GetLocalName();
  
  Returns the calling machine's network name.

GetLocalAddress();

  Returns the calling machine's local IP address.

new ListeningSocket(port[, backlog_size]);
  
  Constructs a new listening socket which listens for connections on `port`.
  `backlog_size` specifies the size of the backlog. If the backlog fills, new
  connections will be dropped.

ListeningSocket:accept();

  If one or more connections are waiting in the backlog, accepts one of them and
  returns an IOSocket object representing the connection. Otherwise, returns
  null. This should be called regularly to prevent the backlog from filling up.

ListeningSocket:close();
  
  Disconnects the socket. Any sockets in the backlog will be purged and no new
  connections can be made unless a new ListeningSocket is created.

new IOSocket(hostname, port);
  
  Connects to `hostname` on `port` and constructs an IOSocket representing the
  connection. The hostname can either be a named address (e.g. google.com) or an
  IP address (e.g. 127.0.0.1). As this operation is non-blocking, a valid socket
  will be returned even if the connection can be not be made; you must call
  IOSocket:isConnected() to find out when the connection has opened.

IOSocket:remoteAddress (read-only)
  
  Gets the IP address of the upstream end of the socket. Throws an error if
  accessed before a connection has been established.

IOSocket:remotePort (read-only)
  
  Gets the port that the remote machine is using for the connection. Generally
  not a useful statistic, but it's there if you need it. Throws an error if
  accessed before a connection is established.

IOSocket:isConnected();
  
  Returns true if the a connection has been established. As long as this returns
  false, you cannot call any other methods on the socket object. Doing so will
  cause an error to be thrown.

IOSocket:getPendingReadSize();
  
  Gets the amount of data, in bytes, currently in the receive buffer. Call
  IOSocket:read() or :readString() to retrieve this data.

IOSocket:read(bytes);
  
  Reads up to `bytes` bytes from the socket and returns a ByteArray containing
  the data received.

IOSocket:readString(bytes);
  
  Same as IOSocket:read(), but returns a string instead of a ByteArray. This may
  be more convenient, depending on your use case.

IOSocket:write(data);

  Writes data to the socket, which can be read at the other end. `data` can be
  either a ByteArray or a string.

IOSocket:close();

  Disconnects the socket. Note that a socket object cannot be reused after it
  has been closed; a new one must be created.
  

File and Directory Management
-----------------------------

These functions allow you to manage the file system. For all of these functions,
file and directory names are relative to ~/save.

GetFileList([dirname]);
  
  'dirname' is relative to ~/ unless escaped.
  
  Returns an array of strings naming files found in the specified directory. If
  'dirname' is not provided, ~/save is assumed.

GetDirectoryList([dirname]);
  
  'dirname' is relative to ~/ unless escaped.
  
  Returns an array of strings naming subdirectories found in the specified
  directory. If 'dirname' is not provided, ~/ is assumed. This is inconsistent
  with GetFileList(), but is compatible with Sphere 1.5.

DoesFileExist(filename);

  Returns true if the specified file exists, false otherwise.

CreateDirectory(dirname);

  Recursively creates a directory. It is safe to call this function if the
  directory already exists. In that case, nothing happens.

RemoveDirectory(dirname);
  
  Removes the specified directory from the file system. The directory must be
  empty, otherwise an error will be thrown.

RemoveFile(filename);
  
  Deletes a file from the file system. If the file cannot be deleted, an error
  will be thrown.

Rename(filename, new_filename);
  
  Renames a file on the file system. If the file cannot be renamed, an error
  will be thrown.


File I/O
--------

When developing a game, at some point you will need to be able to read and write
data to a file, whether to save and load game progress or something else.

new File(filename);

  Opens a file. The file format used for the File object is similar to a Windows
  INI file, containing key/value pairs separated by an equals sign, for
  instance:
    
    playerName=maggie
    playtime=812:00:00
    currentMap=foodville.rmp
    # etc.

File:read(key, defval);
  
  Reads a value from the file. If the key doesn't exist in the file, 'defval'
  is returned. Note that the return type depends on the type of 'defval', either
  boolean (true/false), number, or string.

File:write(key, value);
  
  Writes a value to the file under a specified key. If the key already exists,
  it will be overwritten. Note that writes are cached, and not written to the
  file until it flushed, either by calling File:flush() or automatically when
  it is closed.

File:flush()

  Flushes the file. All pending changes will be written out to the file system.
  The file will remain open afterwards.

File:close()
  
  Closes the file, writing any changes out to the file system in the process.
  You should not call any other methods on the object after this (it is safe to
  call File:close() more than once, however). Doing so will throw an error.
  
new RawFile(filename[, is_writable]);
  
  'filename' is relative to ~/other unless escaped.
  
  Opens a binary file, allowing raw data to be read and/or written. If
  'is_writable' is false, the file must exist and will be opened for reading
  only. Otherwise, the file is overwritten (be careful!) and opened for writing.
  If it cannot be opened for writing, an error will be thrown.

RawFile:position (read/write)
  
  Gets or sets the current file position. This determines where the next read
  or write operation will start.

RawFile:size (read-only)
  
  Gets the current size of the file in bytes. Can also be specified as
  RawFile:length.

RawFile:read([num_bytes]);
  
  Reads data from the file and advances the file position. 'num_bytes' specifies
  the amount of data to read; it can be omitted to read the entire file at once
  (the file position will not change in this case). Returns a ByteArray.

RawFile:readString([num_bytes]);
  
  Like RawFile:read(), but returns a UTF-8 string instead of a ByteArray. This
  may be more convenient in some cases.

RawFile:write(data);
  
  Writes data to the file and advances the file position. The file must be
  opened for writing or an error will be thrown. 'data' can be either a
  ByteArray or a string. Strings are written as UTF-8.

RawFile:close();
  
  Closes the file. You should not call any other methods on the object after
  this (it is safe to call RawFile:close() more than once, however). Doing so
  will throw an error.

  

Map Engine
----------

minisphere's map engine is fully compatible with the one found in Sphere 1.5 and
very powerful.  It's also very easy to get up and running. This section is
incomplete; the APIs below are only the basics. See the included Sphere 1.5 API
documentation for the full set of map functions.

MapEngine(filename, framerate);

  'filename' is relative to ~/maps unless escaped.
  
  Starts the map engine, loading `map_file` as the initial map. `framerate`
  specifies the framerate the map engine will run at; a framerate of 0 will run
  unthrottled, which may be useful for benchmarks but is generally useless
  otherwise.
  
IsMapEngineRunning();
  
  Returns true if the map engine is currently running.

ChangeMap(filename);

  'filename' is relative to ~/maps unless escaped.
  
  Loads a new map into the map engine. This destroys any transient persons
  automatically. Transient persons are those defined in the map file as well as
  any created by passing `true` as the third argument to CreatePerson().

MapToScreenX(layer, x);
MapToScreenY(layer, y);
ScreenToMapX(layer, x);
ScreenToMapY(layer, y);

  Converts between map and screen coordinates.

SetUpdateScript(fn);
SetRenderScript(fn);
  
  Sets a function `fn` to be called once per map engine frame. Game state should
  be updated in the update script, while drawing is done in the render script.
  The distinction is important, as render calls can be skipped to minimize lag.
  Note: You shouldn't call these functions when using miniRT. The runtime uses
  them internally and changing them out will break things.

SetMapEngineFrameRate(fps);
GetMapEngineFrameRate();

  Gets or sets the map engine framerate. Set it to 0 to run the map engine
  unthrottled (not generally useful outside of benchmarks).

GetCurrentMap();
  
  Gets the filename of the current map, relative to ~/maps.

AttachInput(name);
DetachInput();
IsInputAttached();
GetInputPerson();
  
  Attaches, detaches or gets the input focus. The player will have control of
  the person with input focus. `name` is the name of the person as passed to
  CreatePerson().

AttachCamera(name);
DetachCamera();
IsCameraAttached();
GetCameraPerson();
  
  Attaches, detaches, or gets the camera focus. The camera will remain centered
  on whichever person it's attached to as they move about the map. `name` is the
  name of the person as passed to CreatePerson().

SetCameraX();
SetCameraY();
GetCameraX();
GetCameraY();

Gets or sets the camera position. Note: If the camera is placed beyond the edge
of a non-repeating map, the map's corresponding edge script will be called.

UpdateMapEngine();
  
  Updates the map engine per frame. Used to keep the map engine operating in
  the background when running a tight loop. Note that map input will not be
  accepted during an UpdateMapEngine() loop.

RenderMap();
  
  Renders the current map and set of persons to the backbuffer. Used
  along with UpdateMapEngine() to keep the map engine operating when
  running a tight loop.

ExitMapEngine();
  
  Tells the map engine to shut down at the start of the next frame. If
  the map engine is presently held up in an UpdateMapEngine() loop (see
  below), this call will not take effect until control returns to the
  map engine proper.


Trigger Management
------------------

A trigger is a non-obstructing entity which automatically executes custom code
when stepped on by a player-controlled person. This is useful for triggering
events when the player reaches a certain point while exploring, as well as
implementing warp points between maps.

Note that trigger modifications at runtime are transient. This means they will
need to be redone if the map is reloaded. Persistent modifications require
triggers to be edited in the map file itself.

GetCurrentTrigger();
  
  When called in a trigger script, returns the trigger ID of the executing
  trigger. Calling this in any other context will throw an error.

AddTrigger(x, y, layer, script);
  
  Adds a trigger to the current map and returns its trigger ID. 'script' can be
  either a code string or a function. Triggers created this way are transient
  and will need to be recreated if the map is reloaded. For compatibility
  reasons, the layer is ignored by the engine when processing triggers.

RemoveTrigger(trigger_id);

  Removes the trigger with the specified trigger ID from the map. As with
  AddTrigger(), the modification is transient.

GetNumTriggers();
  
  Gets the number of triggers on the current map.

GetTriggerX(trigger_id);
GetTriggerY(trigger_id);
GetTriggerLayer(trigger_id);
SetTriggerXY(trigger_id, x, y);
SetTriggerLayer(trigger_id, layer);

  Gets or sets the location of a trigger on the map, in pixels.

SetTriggerScript(trigger_id, script);
  
  Sets the specified trigger's script. Like most trigger modifications, this is
  transient.

IsTriggerAt(x, y, layer);
  
  Returns true if there is a trigger at the specified location, false otherwise.
  'layer' is required, but ignored for compatibility reasons.

ExecuteTrigger(x, y, layer);
  
  Fires the trigger at the specified location, if one exists. As above, 'layer'
  is required but ignored.
  

Zone Management
---------------

Zones are similar to triggers, except they can cover more than one tile and run
their associated scripts periodically as long as the player is moving and
remains inside the zone. A potential use for these is implementing random
battles. They have other uses as well, as demonstrated in the Lithonite demo
included with the engine.

As with triggers, all zone modifications at runtime are transient.

GetCurrentZone();
  
  When called in a zone script, returns the zone ID of the executing zones.
  Calling this in any other context will throw an error.

AddZone(x, y, width, height, layer, script);

  Adds a zone to the current map. 'script' can be either a code string or a
  function. As with triggers, the layer is ignored by the engine when processing
  zones.

RemoveZone(zone_id);

  Removes the zone with the specified zone ID from the map.

GetNumZones();
  
  Returns the number of zones on the current map.

GetZoneX(zone_id);
GetZoneY(zone_id);
GetZoneWidth(zone_id);
GetZoneHeight(zone_id);
GetZoneLayer(zone_id);
SetZoneMetrics(zone_id, x, y, width, height[, layer]);

  Gets or sets the location and size of a zone, in pixels.

GetZoneSteps(zone_id);
SetZoneSteps(zone_id);
  
  Gets or sets the zone's step count. The zone script will execute every time
  the input character takes this number of steps while inside the zone.

AreZonesAt(x, y, layer);
  
  Returns true if the specified point is inside of a zone, or false otherwise.
  'layer' is required, but ignored for compatibility reasons.

ExecuteZones(x, y, layer);
  
  Executes the scripts of all zones straddling the specified point, if any. As
  above, 'layer' is required but ignored.


Persons Management
------------------

Persons are the Sphere term for what most RPG map engines call 'entities'.  They
are so named for their typical use case--representing persons on a map.
Typically you create one or more persistent persons to represent your player
characters, and the rest are transient, to be destroyed when a new map is
loaded.

CreatePerson(name, spriteset, transient);
  
  Creates a person using the spriteset specified by `spriteset`. This can either
  be an .rss spriteset path (relative to ~/spritesets) or a Spriteset object.
  If `transient` true, the person is transient and will automatically be
  destroyed when a new map is loaded via ChangeMap().

DestroyPerson(name);
  
  Destroys the person, removing it from play. This works on persons
  created manually via CreatePerson() as well as those created during
  map load, so be careful!

GetPersonList();
  
  Returns an array of person names representing all the persons that
  currently exist.

DoesPersonExist(name);
  
  Returns true if a person named `name` currently exists, otherwise
  returns false.

GetPersonX(name);
GetPersonY(name);
GetPersonLayer(name);
SetPersonX(name, new_x);
SetPersonY(name, new_y);
SetPersonLayer(name, layer);

  Gets or sets a person's position relative to the current map. `layer` can be
  either a 0-based layer index or a layer name. Note: For compatibility reasons,
  GetPersonLayer() always returns the index.

SetPersonXYFloat(name, new_x, new_y);
GetPersonXFloat(name);
GetPersonYFloat(name);

  Gets or sets a person's position relative to the current map, with
  subpixel precision.

SetPersonDirection(name, new_dir);
GetPersonDirection(name);

  Gets or sets a person's current direction. The "direction" is actually the
  name of a pose as defined in the person's spriteset. Note: A spriteset is
  required to have a pose for at least each of the 4 cardinal directions (north,
  east, south and west).

FollowPerson(name, leader_name, distance);

  Makes a person follow another person at a distance specified by
  `distance`. Note that the distance is not absolute and the actual
  trailing distance depends on the leader's speed. Faster leaders will
  put more distance between themselves and their followers.
  
  To detach a follower and make them independent again, call the
  function again like this:
    
    FollowPerson("<name>", null, 0);

GetPersonLeader(name);
  
  Gets the person `name` is currently following. If no leader exists
  (the person is independent), returns an empty string ("").

GetPersonFollowers(name);

  Gets an array of names of persons following a specified person.

GetPersonFollowDistance(name);
SetPersonFollowDistance(name);
  
  Gets or sets the named person's follow distance. Throws an error if
  the person is not following anyone.

IsPersonVisible()
SetPersonVisible(is_visible)

  Gets or sets the person's visibility status. 'true' if visible, 'false' if
  not.

IsPersonObstructed(name, x, y);
  
  Checks whether the person would be obstructed at a given location. Useful for
  pathfinding.

GetObstructingPerson(name, x, y);
  
  If the person named `name` is obstructed by a person at the given location,
  returns the offending person's name. Otherwise, returns an empty string ("").

GetObstructingTile(name, x, y);
  
  If the person named `name` is obstructed by a map tile at the given location,
  returns the tile index. Otherwise, returns -1.

SetPersonSpeed(name, speed);
SetPersonSpeedXY(name, new_speed_x, new_speed_y);
GetPersonSpeedX(name);
GetPersonSpeedY(name);

  Gets or sets the person's speed in two dimensions. SetPersonSpeed(name, speed)
  is shorthand for SetPersonSpeedXY(name, speed, speed).

SetPersonSpriteset(name, spriteset);
GetPersonSpriteset(name);

  Gets the person's current spriteset as a Spriteset object.

IsIgnoringPersonObstructions(name);
IgnorePersonObstructions(name, ignore);

  Gets or sets whether the person is ignoring other persons. Ignored persons
  do not affect collision and cannot be talked to. Note that ignoring is mutual
  between persons.

IsIgnoringTileObstructions(name);
IgnoreTileObstructions(name, ignore);

  Gets or sets whether the person is ignoring tile obstructions. As with ignored
  persons, this disables tile collision.

QueuePersonCommand(name, command[, is_immediate]);

  Adds a command to the person's command queue. If `is_immediate` is true, the
  engine will immediately execute the next command in the queue. Otherwise,
  execution will halt until the next frame. The default is false. The following
  commands are supported:
    
    COMMAND_WAIT - do nothing, useful as a non-immediate command to delay for 
                   a frame.
    
    COMMAND_ANIMATE - advances the person's animation state by one frame. Queue
                      these continuously to animate the sprite.
    
    COMMAND_FACE_NORTH
    COMMAND_FACE_NORTHEAST
    COMMAND_FACE_EAST
    COMMAND_FACE_SOUTHEAST
    COMMAND_FACE_SOUTH
    COMMAND_FACE_SOUTHWEST
    COMMAND_FACE_WEST
    COMMAND_FACE_NORTHWEST
      
      Changes the person's facing direction. If the specified direction isn't
      available in the person's spriteset, the engine will use the closest
      match.
    
    COMMAND_MOVE_NORTH
    COMMAND_MOVE_NORTHEAST
    COMMAND_MOVE_EAST
    COMMAND_MOVE_SOUTHEAST
    COMMAND_MOVE_SOUTH
    COMMAND_MOVE_SOUTHWEST
    COMMAND_MOVE_WEST
    COMMAND_MOVE_NORTHWEST
      
      Moves the person a number of pixels determined by their speed. See
      SetPersonSpeed() above.

QueuePersonScript(name, script[, is_immediate]);
  
  Adds a script to the person's command queue. `is_immediate` has the same
  meaning and semantics as in QueuePersonCommand() above. `script` can be either
  a JavaScript source string or a function.

IsCommandQueueEmpty(name);
  
  Returns true if the person's command queue is empty, false otherwise.

ClearCommandQueue(name);
  
  Removes all commands and scripts from the person's command queue.


Tileset Management
------------------

These functions aren't generally needed for most use cases. They are used to
modify the current map's tileset. As with most map modifications, these are
transient and must be redone if the map is reloaded.

GetNumTiles();

  Returns the number of the tiles in the current map's tileset.

GetTileDelay(tile_id);
SetTileDelay(tile_id, frames);

  Gets or sets a tile's animation delay. This is the number of frames which
  must elapsed before the tile switches to the next one in its animation
  sequence.

GetNextAnimatedTile(tile_id);
SetNextAnimatedTile(tile_id, next_tile_id);

  Gets or sets the next tile in the tile animation sequence.

GetTileImage(tile_id);
SetTileImage(tile_id, image);

  Gets or sets the Image associated with a tile. The dimensions of the Image
  must match the tile dimensions, or an error will be thrown.

GetTileSurface(tile_id);
SetTileSurface(tile_id, surface);

  Like Get/SetTileImage(), but uses Surface objects instead. Note: Drawing to
  the Surface after calling either of these functions will not modify the tile.

